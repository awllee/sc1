<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>Performance - SC1</title>
    <meta property="og:title" content="Performance - SC1">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="Code written in R will often fail to have good performance, in the sense that it would run faster if written in a language such as C. The main exception is when the computationally intensive code is &amp;hellip;">
      <meta property="og:description" content="Code written in R will often fail to have good performance, in the sense that it would run faster if written in a language such as C. The main exception is when the computationally intensive code is &amp;hellip;">
      
    

    
    

    

    
    


<link href='//cdn.bootcss.com/highlight.js/9.12.0/styles/github.min.css' rel='stylesheet' type='text/css' />



    <link rel="stylesheet" href="/sc1/css/style.css" />
    <link rel="stylesheet" href="/sc1/css/fonts.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Arvo">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Marcellus">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro">

<link rel="stylesheet" href="/sc1/css/custom.css" />

<link rel="icon" href="/sc1/favicon.ico" type="image/x-icon" />























<nav class="breadcrumbs">
    
        <a href="https://awllee.github.io/sc1/">home / </a>
    
        <a href="https://awllee.github.io/sc1/profile-debug/">profile-debug / </a>
    
        <a href="https://awllee.github.io/sc1/profile-debug/performance/">performance / </a>
    
</nav>

  </head>

  
  <body class="sc1">
    <header class="masthead">
      <h1><a href="/sc1/">SC1</a></h1>

<p class="tagline">Statistical Computing 1</p>

      <nav class="menu">
  <input id="menu-check" type="checkbox" />
  <label id="menu-label" for="menu-check" class="unselectable">
    <span class="icon close-icon">✕</span>
    <span class="icon open-icon">☰</span>
    <span class="text">Menu</span>
  </label>
  <ul>
  
  
  <li><a href="/sc1/">Home</a></li>
  
  <li><a href="/sc1/intro-r/">Intro to R</a></li>
  
  <li><a href="/sc1/reproducibility/">Reproducibility</a></li>
  
  <li><a href="/sc1/common-r/">Common R</a></li>
  
  <li><a href="/sc1/tidyverse/">Tidyverse</a></li>
  
  <li><a href="/sc1/packages/">Packages</a></li>
  
  <li><a href="/sc1/functional-oo/">Functional / OO</a></li>
  
  <li><a href="/sc1/profile-debug/">Performance / Bugs</a></li>
  
  <li><a href="/sc1/matrices/">Matrices</a></li>
  
  <li><a href="/sc1/optimization/">Optimization</a></li>
  
  <li><a href="/sc1/integration/">Integration</a></li>
  
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
<h1>Performance</h1>

<h3>
</h3>
<hr>


      </header>





<div id="TOC">
<ul>
<li><a href="#optimized-routines">Optimized routines</a></li>
<li><a href="#memory-management">Memory management</a></li>
<li><a href="#column-major-storage">Column-major storage</a></li>
<li><a href="#example-logistic-regression">Example: logistic regression</a></li>
<li><a href="#example-matrix-vector-multiplications">Example: matrix vector multiplications</a></li>
<li><a href="#writing-code-in-another-language">Writing code in another language</a></li>
</ul>
</div>

<div id="optimized-routines" class="section level2">
<h2>Optimized routines</h2>
<p>Code written in R will often fail to have good performance, in the sense that it would run faster if written in a language such as C. The main exception is when the computationally intensive code is essentially delegated to optimized library code. A primary example is linear algebra operations, which are performed by a separate library. Many package functions and core R routines are written in C.</p>
</div>
<div id="memory-management" class="section level2">
<h2>Memory management</h2>
<p>One of R’s main features is its pass-by-value semantics. While this makes the language easy to use and reason about, it can make it very difficult to write code that has good performance. In particular, after algorithmic complexity, memory management is one of the most important performance issues in practice.</p>
<p>Of course, there are some hidden optimizations that R performs to improve performance. For example, when one updates elements of an array in a for loop, multiple copies of the array are not made, which would make the time complexity <span class="math inline">\(O(n^2)\)</span>, where <span class="math inline">\(n\)</span> is the size of the array.</p>
<pre class="r"><code>add.one &lt;- function(x) {
  for (i in 1:length(x)) {
    x[i] &lt;- x[i] + 1
  }
  x
}

a1 &lt;- rep(0,5000)
a2 &lt;- rep(0,10000)

library(microbenchmark)
microbenchmark(add.one(a1))</code></pre>
<pre><code>## Unit: microseconds
##         expr     min      lq    mean  median       uq      max neval
##  add.one(a1) 286.923 289.854 516.591 303.283 308.8815 21703.25   100</code></pre>
<pre class="r"><code>microbenchmark(add.one(a2))</code></pre>
<pre><code>## Unit: microseconds
##         expr     min      lq     mean   median       uq      max neval
##  add.one(a2) 602.407 606.451 1248.489 638.1895 1232.741 28191.87   100</code></pre>
<p>On the other hand, small changes in the code (that would not affect performance in languages that pass by reference) can cause many copies of the array to made.</p>
<pre class="r"><code>add.one.bad &lt;- function(x) {
  y &lt;- x
  for (i in 1:length(x)) {
    x[i] &lt;- x[i] + 1
    y &lt;- x
  }
  x
}

add.one.index &lt;- function(x, i) {
  x[i] &lt;- x[i] + 1
  x
}

add.one.slow &lt;- function(x) {
  for (i in 1:length(x)) {
    x &lt;- add.one.index(x, i)
  }
  x
}

system.time(add.one.bad(a1))</code></pre>
<pre><code>##    user  system elapsed 
##   0.062   0.072   0.137</code></pre>
<pre class="r"><code>system.time(add.one.bad(a2))</code></pre>
<pre><code>##    user  system elapsed 
##   0.216   0.272   0.606</code></pre>
<pre class="r"><code>system.time(add.one.slow(a1))</code></pre>
<pre><code>##    user  system elapsed 
##   0.077   0.077   0.220</code></pre>
<pre class="r"><code>system.time(add.one.slow(a2))</code></pre>
<pre><code>##    user  system elapsed 
##   0.304   0.262   0.571</code></pre>
</div>
<div id="column-major-storage" class="section level2">
<h2>Column-major storage</h2>
<p>When a matrix is stored in memory, a language typically maps its entries to a contiguous block of memory. This is done using either <a href="https://en.wikipedia.org/wiki/Row-_and_column-major_order">column-major or row-major order</a>. In R, column-major order is used, which means that elements in each column are stored in contiguous blocks.</p>
<p>This has a performance implication, although in R the effects are often overshadowed by other performance penalties. To see the difference, consider the following functions, which fill an <span class="math inline">\(n \times n\)</span> matrix with <span class="math inline">\(1\)</span>s.</p>
<pre class="r"><code>fill.by.column &lt;- function(n) {
  x &lt;- rep(1,n)
  X &lt;- matrix(0,n,n)
  for (i in 1:n) {
    X[,i] &lt;- x
  }
  X
}

fill.by.row &lt;- function(n) {
  x &lt;- rep(1,n)
  X &lt;- matrix(0,n,n)
  for (i in 1:n) {
    X[i,] &lt;- x
  }
  X
}</code></pre>
<p>These functions are not useful at all, one could just use <code>matrix(1,n,n)</code> instead. We are interested here only in their performance, which is quite different.</p>
<pre class="r"><code>n &lt;- 10000
system.time(Y1 &lt;- fill.by.column(n))</code></pre>
<pre><code>##    user  system elapsed 
##   0.460   0.402   0.913</code></pre>
<pre class="r"><code>system.time(Y2 &lt;- fill.by.row(n))</code></pre>
<pre><code>##    user  system elapsed 
##   2.112   0.426   2.637</code></pre>
<p>Filling the matrix column by column is faster because reading and writing memory in contiguous blocks is faster than reading and writing memory locations that are far apart.</p>
</div>
<div id="example-logistic-regression" class="section level2">
<h2>Example: logistic regression</h2>
<p>Consider the logistic regression model</p>
<p><span class="math display">\[Y_i \overset{\text{ind}}{\sim} {\rm Bernoulli}(\sigma(\theta^T x_i)), \qquad i \in \{1,\ldots,n\},\]</span>
where <span class="math inline">\(x_1,\ldots,x_n\)</span> are <span class="math inline">\(d\)</span>-dimensional real vectors of explanatory variables, and <span class="math inline">\(\sigma\)</span> is the standard logistic function
<span class="math display">\[\sigma(z) = \frac{1}{1+\exp(-z)}.\]</span>
The data consists of observed realizations of <span class="math inline">\((Y_1,\ldots,Y_n)\)</span>, <span class="math inline">\(y = (y_1,\ldots,y_n)\)</span>, as well as <span class="math inline">\((x_1,\ldots,x_n)\)</span>. We define the <span class="math inline">\(n \times d\)</span> matrix <span class="math inline">\(X = (x_{ij})\)</span>.</p>
<p>It is a nice little exercise to derive the log-likelihood, as well as its gradient (i.e. the score) and Hessian, using the fact that <span class="math inline">\(\sigma&#39;(z) = \sigma(z)[1-\sigma(z)]\)</span>.</p>
<p><span class="math display">\[\ell(\theta ; y) = \sum_{i=1}^n y_i \log (\sigma(\theta^Tx_i)) + (1-y_i) \log (1 - \sigma(\theta^Tx_i)).\]</span></p>
<p><span class="math display">\[\begin{equation}
\label{eq:scorecomponent}
\frac{\partial \ell (\theta ; y)}{\partial \theta_j} = \sum_{i=1}^n [y_i - \sigma(\theta^T x_i)] x_{ij},\qquad j \in \{1,\ldots,d \}.
\end{equation}\]</span></p>
<p><span class="math display">\[\begin{equation}
\label{eq:hessiancomponents}
\frac{\partial^2 \ell (\theta ; y)}{\partial \theta_j \partial \theta_k} = - \sum_{i=1}^n \sigma(\theta^T x_i) [1 - \sigma(\theta^T x_i)] x_{ij} x_{ik},\qquad j,k \in \{1,\ldots,d \}.
\end{equation}\]</span></p>
<p>In fact,  implies that the score can be written as
<span class="math display">\[\nabla \ell(\theta; y) = X^T [y - p(\theta)],\]</span>
where <span class="math inline">\(p(\theta)\)</span> is the vector <span class="math inline">\((p_1(\theta),\ldots,p_n(\theta)\)</span> where <span class="math inline">\(p_i(\theta) = \sigma(\theta^T x_i)\)</span>.</p>
<p>Similarly,  implies that the Hessian can be written as
<span class="math display">\[\nabla^2 \ell(\theta; y) = - X^T D(\theta) X,\]</span>
where <span class="math inline">\(D(\theta)\)</span> is the <span class="math inline">\(n \times n\)</span> diagonal matrix where the <span class="math inline">\(i\)</span>th diagonal entry is <span class="math inline">\(p_i(\theta)[1-p_i(\theta)]\)</span> for <span class="math inline">\(i \in \{1,\ldots,d\}\)</span>.</p>
<p>It is not hard to see that R functions which perform matrix-vector multiplications have much better performance than equivalent functions relying on for loops.</p>
<pre class="r"><code>sigma &lt;- function(v) {
  1/(1+exp(-v))
}

ell &lt;- function(theta, X, y) {
  p &lt;- as.vector(sigma(X%*%theta))
  sum(y*log(p) + (1-y)*log(1-p))
}

score &lt;- function(theta, X, y) {
  p &lt;- as.vector(sigma(X%*%theta))
  as.vector(t(X)%*%(y-p))
}

hessian &lt;- function(theta, X) {
  p &lt;- as.vector(sigma(X%*%theta))
  -t(X)%*%((p*(1-p))*X)
}</code></pre>
<pre class="r"><code>ell.slow &lt;- function(theta, X, y) {
  n &lt;- length(y)
  ll &lt;- 0
  for (i in 1:n) {
    v &lt;- sigma(sum(X[i,]*theta))
    ll &lt;- ll + y[i]*log(v) + (1-y[i])*log(1-v)
  }
  ll
}

score.slow &lt;- function(theta, X, y) {
  n &lt;- length(y)
  score &lt;- 0
  for (i in 1:n) {
    v &lt;- sigma(sum(X[i,]*theta))
    score &lt;- score + (y[i]-v)*X[i,]
  }
  score
}</code></pre>
<pre class="r"><code>generate.y &lt;- function(X, theta) {
  n &lt;- dim(X)[1]
  rbinom(n, size = 1, prob=sigma(X%*%theta))
}

maximize.ell &lt;- function(ell, score, X, y, theta0) {
  optim.out &lt;- optim(theta0, fn=ell, gr=score, X=X, y=y, method=&quot;BFGS&quot;,
                     control=list(fnscale=-1, maxit=1000, reltol=1e-16))
  optim.out$par
}</code></pre>
<pre class="r"><code>d &lt;- 10
n &lt;- 10000
X &lt;- matrix(rnorm(n*(d-1)), n, d-1)
X &lt;- cbind(1, X)
theta.true &lt;- rnorm(d)
theta.true</code></pre>
<pre><code>##  [1] -0.3381863  0.3768420 -1.5907567  0.9558548 -0.6315606  0.2271664
##  [7] -0.2440201  1.3543592 -1.4269040  0.9501143</code></pre>
<pre class="r"><code>y &lt;- generate.y(X, theta.true)

system.time(mle &lt;- maximize.ell(ell, score, X, y, rep(0,d)))</code></pre>
<pre><code>##    user  system elapsed 
##   0.131   0.023   0.155</code></pre>
<pre class="r"><code>mle</code></pre>
<pre><code>##  [1] -0.3086353  0.3663861 -1.5955518  0.9400704 -0.6404206  0.1462028
##  [7] -0.2882861  1.3637807 -1.3990792  0.9557187</code></pre>
<pre class="r"><code>system.time(mle &lt;- maximize.ell(ell.slow, score.slow, X, y, rep(0,d)))</code></pre>
<pre><code>##    user  system elapsed 
##   5.068   0.051   5.525</code></pre>
<pre class="r"><code>mle</code></pre>
<pre><code>##  [1] -0.3086353  0.3663860 -1.5955518  0.9400705 -0.6404207  0.1462028
##  [7] -0.2882862  1.3637807 -1.3990793  0.9557188</code></pre>
</div>
<div id="example-matrix-vector-multiplications" class="section level2">
<h2>Example: matrix vector multiplications</h2>
<p>Here we consider the simple example of performing either <span class="math inline">\(m\)</span> matrix-vector multiplications or a large matrix-matrix multiplication.</p>
<pre class="r"><code>n &lt;- 10000
p &lt;- 200
m &lt;- 500

A &lt;- matrix(rnorm(n*p), n, p)
B &lt;- matrix(rnorm(p*m), p, m)

foo &lt;- function(A, B) {
  C &lt;- matrix(0, n, m)
  for (i in 1:m) {
    C[,i] &lt;- A%*%B[,i]
  }
  C
}

system.time(C &lt;- A%*%B)</code></pre>
<pre><code>##    user  system elapsed 
##   0.789   0.022   0.898</code></pre>
<pre class="r"><code>system.time(C.alt &lt;- foo(A, B))</code></pre>
<pre><code>##    user  system elapsed 
##   1.642   0.042   1.770</code></pre>
<pre class="r"><code>norm(C-C.alt)</code></pre>
<pre><code>## [1] 0</code></pre>
<p>Clearly, the matrix-matrix multiplication is more computationally efficient. This is because the implementation of matrix multiplication is <a href="https://en.wikipedia.org/wiki/Matrix_multiplication_algorithm">highly optimized</a> and is not implemented by performing several matrix-vector multiplications.</p>
<p>In some applications one might need to perform several matrix-vector multiplications with the same vector. For performance, it is better to combine the vectors in a matrix. However, this can sometimes also lead to code that is harder to understand, extend and maintain. So it is usually a good idea to use profiling to ensure that any performance improvements that come at the cost of easily understandable and maintainable code are appropriately justified.</p>
</div>
<div id="writing-code-in-another-language" class="section level2">
<h2>Writing code in another language</h2>
<p>In Statistical Computing 2 you will learn how to use <a href="http://www.rcpp.org/">Rcpp</a> to write C++ code that is easily called from within R. This is one of the main routes to improving the performance of functions on the critical pathway for an application.</p>
<p>Most other high-level, scientific computing languages have the similar mechanisms for calling C or C++ code. This is a very powerful mechanism for improving performance, as one has complete control over what is computed, but involves writing and maintaining code in two languages, as well as maintaining an interface between the two languages.</p>
</div>


  <footer>
  

<script src="//yihui.name/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.name/js/center-img.js"></script>


<script type="text/javascript">
var sc_project=12110974;
var sc_invisible=1;
var sc_security="9b171880";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>
<noscript><div class="statcounter"><a title="Web Analytics"
href="https://statcounter.com/" target="_blank"><img
class="statcounter"
src="https://c.statcounter.com/12110974/0/9b171880/1/"
alt="Web Analytics"></a></div></noscript>








  


<p align=right>

<a href='https://github.com/awllee/sc1/blob/master/content/profile-debug/performance.Rmd'>View source</a>

|

<a href='https://github.com/awllee/sc1/edit/master/content/profile-debug/performance.Rmd'>Edit source</a>

</p>





<script src="https://utteranc.es/client.js"
        repo="awllee/sc1"
        issue-term="pathname"
        label="utterance"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



  



<script src="//cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>



<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/r.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/yaml.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/9.12.0/languages/tex.min.js"></script>
<script>hljs.configure({languages: []}); hljs.initHighlightingOnLoad();</script>



  
  <hr>
  <div class="copyright">© 2020 <a href="https://sites.google.com/view/anthonylee">Anthony Lee</a>, <a href="http://www.bristol.ac.uk/maths/people/feng-yu/index.html">Feng Yu</a>, <a href="https://people.maths.bris.ac.uk/~tk18582/">Tobias Kley</a>, <a href="https://mfasiolo.github.io/">Matteo Fasiolo</a></div>
  
  </footer>
  </article>
  
  </body>
</html>

