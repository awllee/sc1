<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    
    <title>5. Data reshaping with dplyr and tidyr - SC1</title>
    <meta property="og:title" content="5. Data reshaping with dplyr and tidyr - SC1">
    
    <meta name="twitter:card" content="summary">

    
      
    

    
      
      <meta property="description" content="This section is the natural continuation of the previous one, which focussed on data transformation with dplyr. Here we show how to use the tidyr package, which provides tools for reshaping your data &amp;hellip;">
      <meta property="og:description" content="This section is the natural continuation of the previous one, which focussed on data transformation with dplyr. Here we show how to use the tidyr package, which provides tools for reshaping your data &amp;hellip;">
      
    

    
    

    

    
    


<link rel="stylesheet" href="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.12.0/build/styles/github.min.css">



    <link rel="stylesheet" href="/css/style.css" />
    <link rel="stylesheet" href="/css/fonts.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Arvo">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Marcellus">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro">

<link rel="stylesheet" href="/css/custom.css" />

<link rel="icon" href="/sc1/favicon.ico" type="image/x-icon" />























<nav class="breadcrumbs">
    
        <a href="https://awllee.github.io/sc1/">home / </a>
    
        <a href="https://awllee.github.io/sc1/tidyverse/">tidyverse / </a>
    
        <a href="https://awllee.github.io/sc1/tidyverse/data_reshaping_tidyr/">data_reshaping_tidyr / </a>
    
</nav>

  </head>

  
  <body class="sc1">
    <header class="masthead">
      <h1><a href="/">SC1</a></h1>

<p class="tagline">Statistical Computing 1</p>

      <nav class="menu">
  <input id="menu-check" type="checkbox" hidden/>
  <label id="menu-label" for="menu-check" class="unselectable" hidden>
    <span class="icon close-icon">✕</span>
    <span class="icon open-icon">☰</span>
    <span class="text">Menu</span>
  </label>
  <ul>
  
  
  <li><a href="/sc1/">Home</a></li>
  
  <li><a href="/sc1/intro-r/">Intro to R</a></li>
  
  <li><a href="/sc1/reproducibility/">Reproducibility</a></li>
  
  <li><a href="/sc1/packages/">Packages</a></li>
  
  <li><a href="/sc1/common-r/">Common R</a></li>
  
  <li><a href="/sc1/functional-oo/">Functional / OO</a></li>
  
  <li><a href="/sc1/tidyverse/">Tidyverse</a></li>
  
  <li><a href="/sc1/profile-debug/">Performance / Bugs</a></li>
  
  <li><a href="/sc1/matrices/">Matrices</a></li>
  
  <li><a href="/sc1/optimization/">Optimization</a></li>
  
  <li><a href="/sc1/integration/">Integration</a></li>
  
  
  </ul>
</nav>

    </header>

    <article class="main">
      <header class="title">
      
<h1>5. Data reshaping with dplyr and tidyr</h1>

<h3>
</h3>
<hr>


      </header>








<style>
body {
text-align: justify}
</style>
<p>This section is the natural continuation of the previous one, which focussed on data transformation with <code>dplyr</code>. Here we show how to use the <code>tidyr</code> package, which provides tools for reshaping your data for the purpose of modelling and visualization, and we will illustrate more features of <code>dplyr</code>. As for the previous sections, here we cover the basics and we refer to the <a href="https://r4ds.had.co.nz/tidy-data.html">relevant chapter</a> of “R for Data Science” for more details.</p>
<div id="pivoting-your-data" class="section level2">
<h2>Pivoting your data</h2>
<p>To illustrate the reshaping tools provided by <code>tidyr</code>, here we look at another electricity demand data set. In particular, we consider an Irish smart meter data set which can be found in the <code>electBook</code> package. At the time of writing <code>electBook</code> is available only on Github, hence we need to install it from there using <code>devtools</code>:</p>
<pre class="r"><code>library(magrittr)
library(tidyr)
library(dplyr)
library(ggplot2)

# Install electBook only if it is not already installed
if( !require(electBook) ){
  library(devtools)
  install_github(&quot;mfasiolo/electBook&quot;)
  library(electBook)
}</code></pre>
<pre><code>## TTR          (NA -&gt; 0.24.3    ) [CRAN]
## xts          (NA -&gt; 0.12.2    ) [CRAN]
## quantmod     (NA -&gt; 0.4.20    ) [CRAN]
## zoo          (NA -&gt; 1.8-11    ) [CRAN]
## quadprog     (NA -&gt; 1.5-8     ) [CRAN]
## RcppArmad... (NA -&gt; 0.11.4.2.1) [CRAN]
## urca         (NA -&gt; 1.3-3     ) [CRAN]
## tseries      (NA -&gt; 0.10-52   ) [CRAN]
## timeDate     (NA -&gt; 4021.107  ) [CRAN]
## lmtest       (NA -&gt; 0.9-40    ) [CRAN]
## fracdiff     (NA -&gt; 1.5-2     ) [CRAN]
## forecast     (NA -&gt; 8.19      ) [CRAN]
## 
## The downloaded binary packages are in
## 	/var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T//RtmpFtjjVT/downloaded_packages
## ── R CMD build ─────────────────────────────────────────────────────────────────
## * checking for file ‘/private/var/folders/24/8k48jl6d249_n_qfxwsl6xvm0000gn/T/RtmpFtjjVT/remotes30857a86d469/mfasiolo-electBook-38d7020/DESCRIPTION’ ... OK
## * preparing ‘electBook’:
## * checking DESCRIPTION meta-information ... OK
## * checking for LF line-endings in source and make files and shell scripts
## * checking for empty or unneeded directories
## * building ‘electBook_0.0.1.tar.gz’</code></pre>
<p>Then we load the smart meter data:</p>
<pre class="r"><code>data(Irish)</code></pre>
<p><code>Irish</code> is a list, where <code>Irish$indCons</code> is a <code>data.frame</code> containing electricity demand data over one year, at 30min resolution, for more than 2000 smart meters. We store it as a separate object:</p>
<pre class="r"><code>indCons &lt;- Irish$indCons
dim(indCons)</code></pre>
<pre><code>## [1] 16799  2672</code></pre>
<pre class="r"><code>head(indCons[ , 1:10])</code></pre>
<pre><code>##      I1002 I1003 I1004 I1005 I1013 I1015 I1018 I1020 I1022 I1024
## 8114 0.022 0.593 2.002 0.755 0.035 0.398 0.547 0.376 0.229 1.030
## 8115 0.133 0.707 1.602 0.898 0.112 0.689 0.603 0.275 0.198 0.807
## 8116 0.094 0.684 1.525 0.736 0.046 0.407 0.511 0.259 0.201 0.859
## 8117 0.023 0.563 1.393 0.738 0.036 0.223 0.593 0.249 0.212 0.210
## 8118 0.133 0.489 1.221 0.849 0.065 0.132 0.570 0.241 0.121 0.056
## 8119 0.090 0.521 1.032 0.695 0.093 0.117 0.481 0.122 0.127 0.169</code></pre>
<p>Each column contains the demand of a different customer. In order to limit the computational burden, below we focus on a subset of 100 customers:</p>
<pre class="r"><code>indCons &lt;- indCons[ , 1:100]</code></pre>
<p>Now, suppose that we want to plot the consumption of some of the customers over time, on the same plot. Using base <code>R</code>, one way of doing this is:</p>
<pre class="r"><code>matplot(indCons[1:(48*7), 1:3], type = &#39;l&#39;)</code></pre>
<p><img src="/sc1/tidyverse/data_reshaping_tidyr_files/figure-html/unnamed-chunk-5-1.png" width="672" style="display: block; margin: auto;" />
Here we are plotting the consumption of the first three customers over the first 7 days (we have 48 observations per day). To do the same in <code>ggplot2</code> we need to put the data in a “long” format, that is we need a <code>data.frame</code> where one column contains the demand values and another indicates to which customer each demand value belongs to. This can be achieved easily using <code>tidyr::pivot_longer</code>:</p>
<pre class="r"><code>longDat &lt;- indCons %&gt;% pivot_longer(cols = everything(), names_to = &quot;ID&quot;, values_to = &quot;dem&quot;) %&gt;% dplyr::arrange(ID)
head(longDat, 5)</code></pre>
<pre><code>## # A tibble: 5 × 2
##   ID      dem
##   &lt;chr&gt; &lt;dbl&gt;
## 1 I1002 0.022
## 2 I1002 0.133
## 3 I1002 0.094
## 4 I1002 0.023
## 5 I1002 0.133</code></pre>
<pre class="r"><code>tail(longDat, 5)</code></pre>
<pre><code>## # A tibble: 5 × 2
##   ID      dem
##   &lt;chr&gt; &lt;dbl&gt;
## 1 I1241 0.166
## 2 I1241 0.278
## 3 I1241 0.103
## 4 I1241 0.116
## 5 I1241 0.073</code></pre>
<p>As you can see, the demand of all the customers has been aligned in a single vector, and the customer ID is reported in a separate column. In the call to <code>pivot_longer</code>, the <code>cols</code> argument specifies the set of columns whose names are values. The <code>names_to</code> argument specifies the name we wish to give to the variable whose values formed the column names in the original data set (the customer IDs). The <code>values_to</code> argument specifies the name we wish to give to the variable whose values were spread over the columns of the original data set (the electricity consumption).</p>
<p>One issue with the long format is that it uses more memory, in fact:</p>
<pre class="r"><code>indCons %&gt;% object.size %&gt;% format(units = &quot;MB&quot;)</code></pre>
<pre><code>## [1] &quot;12.9 Mb&quot;</code></pre>
<pre class="r"><code>longDat %&gt;% object.size %&gt;% format(units = &quot;MB&quot;)</code></pre>
<pre><code>## [1] &quot;25.6 Mb&quot;</code></pre>
<p>This is mainly due to the <code>ID</code> column, which pretty much doubles the memory needed to store our data. The problem can be alleviated by converting the <code>ID</code> variable from a character string to a factor:</p>
<pre class="r"><code>longDat %&lt;&gt;% mutate(ID = as.factor(ID))
longDat %&gt;% object.size %&gt;% format(units = &quot;MB&quot;)</code></pre>
<pre><code>## [1] &quot;19.2 Mb&quot;</code></pre>
<p>The memory saving occurs because we store only one copy of the factor levels (which are character strings). This can be done directly in the call to <code>pivot_longer</code>, by specifying that the <code>names</code> must be transformed into a factor:</p>
<pre class="r"><code>longDat &lt;- indCons %&gt;% pivot_longer(cols = everything(), names_to = &quot;ID&quot;, values_to = &quot;dem&quot;, names_transform = list(ID = as.factor)) %&gt;% dplyr::arrange(ID)
longDat %&gt;% object.size %&gt;% format(units = &quot;MB&quot;)</code></pre>
<pre><code>## [1] &quot;19.2 Mb&quot;</code></pre>
<p>Having put the data in this format, we can try to plot the demand using <code>ggplot2</code>:</p>
<pre class="r"><code>longDat %&gt;% filter(ID %in% levels(ID)[1:3]) %&gt;%
            group_by(ID) %&gt;%
            slice(1:(48 * 7)) %&gt;%
            ggplot(aes(x = 1:nrow(.), y = dem, col = ID)) +
            geom_line()</code></pre>
<p><img src="/sc1/tidyverse/data_reshaping_tidyr_files/figure-html/unnamed-chunk-10-1.png" width="768" style="display: block; margin: auto;" />
Here we are using filter to select the first three customers, then we group the data by customer ID and we use <code>slice</code> to select the first <span class="math inline">\(48 \times 7\)</span> observations for each customers. However, we didn’t quite get the plot we wanted, because the consumption of the three customers does not overlap, but it’s plotted sequentially along the <span class="math inline">\(x\)</span>-axis. To get the <code>ggplot2</code> equivalent of the plot we got with <code>matplot</code>, we need a variable going from 1 to <span class="math inline">\(48 \times 7\)</span> repeatedly for each of the customers. This is achieved as follows:</p>
<pre class="r"><code>longDat %&gt;% filter(ID %in% levels(ID)[1:3]) %&gt;%
            group_by(ID) %&gt;%
            slice(1:(48 * 7)) %&gt;%
            mutate(counter = row_number()) %&gt;%
            ggplot(aes(x = counter, y = dem, col = ID)) +
            geom_line()</code></pre>
<p><img src="/sc1/tidyverse/data_reshaping_tidyr_files/figure-html/unnamed-chunk-11-1.png" width="768" style="display: block; margin: auto;" />
Where we used <code>row_number</code> within <code>mutate</code> to add a new <code>counter</code> variable to the data. <code>counter</code> is shown by the following plot:</p>
<pre class="r"><code>longDat %&gt;% filter(ID %in% levels(ID)[1:3]) %&gt;%
            group_by(ID) %&gt;%
            slice(1:(48 * 7)) %&gt;%
            mutate(counter = row_number()) %&gt;%
            ggplot(aes(x = 1:nrow(.), y = counter, col = ID)) +
            geom_line()</code></pre>
<p><img src="/sc1/tidyverse/data_reshaping_tidyr_files/figure-html/unnamed-chunk-12-1.png" width="768" style="display: block; margin: auto;" /></p>
<p>At this point you might (legitimately!) be wondering whether we would have been better off just sticking to <code>matplot</code>, which was much easier to use in this case. However, notice that once we got our <code>data.frame</code> in the long shape, we can use all the plot types and layers provided by <code>ggplot2</code>. In addition, we can use <code>dplyr</code> and <code>ggplot2</code> to do more complicated things like:</p>
<pre class="r"><code>longDat %&gt;% group_by(ID) %&gt;%
            slice(1:(48 * 7)) %&gt;%
            mutate(counter = row_number()) %&gt;%
            group_by(counter) %&gt;%
            summarise(dem = sum(dem)) %&gt;%
            ggplot(aes(x = 1:nrow(.), y = dem)) +
            geom_smooth() +
            geom_point()</code></pre>
<p><img src="/sc1/tidyverse/data_reshaping_tidyr_files/figure-html/unnamed-chunk-13-1.png" width="768" style="display: block; margin: auto;" />
As an exercises, try to work out what the above code does, and what is being plotted.</p>
<p>For the purpose of illustration, let us add the <code>counter</code> variable to the whole <code>longDat</code> data set:</p>
<pre class="r"><code>longDat %&lt;&gt;% group_by(ID) %&gt;%
             mutate(counter = row_number()) %&gt;%
             ungroup()</code></pre>
<p>where we use <code>ungroup</code> to remove the grouping created by <code>group_by</code>. Now, suppose that we were given <code>longDat</code>, and that we wanted to spread it out on a wide format (as in the original <code>indCons</code> data set). We can achieve this using the <code>tidyr::pivot_wider</code> function:</p>
<pre class="r"><code>wideDat &lt;- longDat %&gt;% pivot_wider(names_from = &quot;ID&quot;, values_from = &quot;dem&quot;)

print(wideDat, n = 5, width = 60, n_extra = 0)</code></pre>
<pre><code>## Warning: The `n_extra` argument of `print()` is deprecated as of pillar 1.6.2.
## ℹ Please use the `max_extra_cols` argument instead.</code></pre>
<pre><code>## # A tibble: 16,799 × 101
##   counter I1002 I1003 I1004 I1005 I1013 I1015 I1018 I1020
##     &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
## 1       1 0.022 0.593  2.00 0.755 0.035 0.398 0.547 0.376
## 2       2 0.133 0.707  1.60 0.898 0.112 0.689 0.603 0.275
## 3       3 0.094 0.684  1.52 0.736 0.046 0.407 0.511 0.259
## 4       4 0.023 0.563  1.39 0.738 0.036 0.223 0.593 0.249
## 5       5 0.133 0.489  1.22 0.849 0.065 0.132 0.57  0.241
## # … with 16,794 more rows</code></pre>
<p>As you can see we got back a wide <code>data.frame</code>, where the values of <code>longDat$ID</code> are variable names. Now, suppose that we wanted to transform <code>wideDat</code> back to a long format. Simply doing the following is not a good idea:</p>
<pre class="r"><code>longDat2 &lt;- wideDat %&gt;% pivot_longer(cols = everything(), names_to = &quot;ID&quot;, values_to = &quot;dem&quot;, names_transform = list(ID = as.factor)) %&gt;% dplyr::arrange(ID)
head(longDat2)</code></pre>
<pre><code>## # A tibble: 6 × 2
##   ID        dem
##   &lt;fct&gt;   &lt;dbl&gt;
## 1 counter     1
## 2 counter     2
## 3 counter     3
## 4 counter     4
## 5 counter     5
## 6 counter     6</code></pre>
<pre class="r"><code>tail(longDat2)</code></pre>
<pre><code>## # A tibble: 6 × 2
##   ID      dem
##   &lt;fct&gt; &lt;dbl&gt;
## 1 I1241 0.354
## 2 I1241 0.166
## 3 I1241 0.278
## 4 I1241 0.103
## 5 I1241 0.116
## 6 I1241 0.073</code></pre>
<p>because the variable <code>counter</code> is considered to be an ID! The solution is specifying which columns we want to gather when reshaping the data:</p>
<pre class="r"><code>longDat2 &lt;- wideDat %&gt;% pivot_longer(cols = I1002:I1241, names_to = &quot;ID&quot;, values_to = &quot;dem&quot;, names_transform = list(ID = as.factor)) %&gt;% dplyr::arrange(ID)
head(longDat2)</code></pre>
<pre><code>## # A tibble: 6 × 3
##   counter ID      dem
##     &lt;int&gt; &lt;fct&gt; &lt;dbl&gt;
## 1       1 I1002 0.022
## 2       2 I1002 0.133
## 3       3 I1002 0.094
## 4       4 I1002 0.023
## 5       5 I1002 0.133
## 6       6 I1002 0.09</code></pre>
<p>where we are using <code>I1002:I1241</code> to specify that we want to gather all the columns included between <code>I1002</code> and <code>I1241</code>. This worked well, but it required us to know the names of the two “limit” columns (<code>I1002</code> and <code>I1241</code>) and there is the assumption that all the columns to be gathered are included between them (which is not always the case). A better alternative is the following:</p>
<pre class="r"><code>longDat3 &lt;- wideDat %&gt;% pivot_longer(cols = starts_with(&quot;I1&quot;), names_to = &quot;ID&quot;, values_to = &quot;dem&quot;, names_transform = list(ID = as.factor)) %&gt;% dplyr::arrange(ID)</code></pre>
<p>where we are using <code>starts_with</code> to gather all the columns that start with the “I1” string. The result is identical:</p>
<pre class="r"><code>identical(longDat2, longDat3)</code></pre>
<pre><code>## [1] TRUE</code></pre>
<p>As an exercise, you might want to think about what the following code does:</p>
<pre class="r"><code>strange &lt;- wideDat %&gt;% pivot_longer(cols = c(I1002, I1003), names_to = &quot;ID&quot;, values_to = &quot;dem&quot;, names_transform = list(ID = as.factor))
strange</code></pre>
<pre><code>## # A tibble: 33,598 × 101
##    counter I1004 I1005 I1013 I1015 I1018 I1020 I1022 I1024 I1027 I1033 I1036
##      &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;
##  1       1  2.00 0.755 0.035 0.398 0.547 0.376 0.229 1.03  0.07  0.79  0.602
##  2       1  2.00 0.755 0.035 0.398 0.547 0.376 0.229 1.03  0.07  0.79  0.602
##  3       2  1.60 0.898 0.112 0.689 0.603 0.275 0.198 0.807 0.041 0.361 0.565
##  4       2  1.60 0.898 0.112 0.689 0.603 0.275 0.198 0.807 0.041 0.361 0.565
##  5       3  1.52 0.736 0.046 0.407 0.511 0.259 0.201 0.859 0.027 0.363 0.527
##  6       3  1.52 0.736 0.046 0.407 0.511 0.259 0.201 0.859 0.027 0.363 0.527
##  7       4  1.39 0.738 0.036 0.223 0.593 0.249 0.212 0.21  0.047 0.215 0.609
##  8       4  1.39 0.738 0.036 0.223 0.593 0.249 0.212 0.21  0.047 0.215 0.609
##  9       5  1.22 0.849 0.065 0.132 0.57  0.241 0.121 0.056 0.019 0.133 0.203
## 10       5  1.22 0.849 0.065 0.132 0.57  0.241 0.121 0.056 0.019 0.133 0.203
## # … with 33,588 more rows, and 89 more variables: I1039 &lt;dbl&gt;, I1041 &lt;dbl&gt;,
## #   I1042 &lt;dbl&gt;, I1044 &lt;dbl&gt;, I1047 &lt;dbl&gt;, I1052 &lt;dbl&gt;, I1054 &lt;dbl&gt;,
## #   I1055 &lt;dbl&gt;, I1057 &lt;dbl&gt;, I1058 &lt;dbl&gt;, I1059 &lt;dbl&gt;, I1060 &lt;dbl&gt;,
## #   I1061 &lt;dbl&gt;, I1062 &lt;dbl&gt;, I1064 &lt;dbl&gt;, I1065 &lt;dbl&gt;, I1067 &lt;dbl&gt;,
## #   I1069 &lt;dbl&gt;, I1073 &lt;dbl&gt;, I1075 &lt;dbl&gt;, I1076 &lt;dbl&gt;, I1077 &lt;dbl&gt;,
## #   I1079 &lt;dbl&gt;, I1081 &lt;dbl&gt;, I1082 &lt;dbl&gt;, I1083 &lt;dbl&gt;, I1086 &lt;dbl&gt;,
## #   I1091 &lt;dbl&gt;, I1093 &lt;dbl&gt;, I1096 &lt;dbl&gt;, I1099 &lt;dbl&gt;, I1102 &lt;dbl&gt;, …</code></pre>
<p>Is the <code>strange</code> dataframe likely to be useful in practice?</p>
</div>
<div id="merging-dataframes-using-joins" class="section level2">
<h2>Merging dataframes using joins</h2>
<p>So far we only looked at <code>Irish$indCons</code>, which contains the individual electricity demand data. However, <code>Irish</code> contains also information about each customer:</p>
<pre class="r"><code>survey &lt;- as_tibble( Irish$survey )
head(survey)</code></pre>
<pre><code>## # A tibble: 6 × 12
##   ID    meanDem SOCIALCL…¹ OWNER…² BUILT…³ HEAT.…⁴ HEAT.…⁵ WINDO…⁶ HOME.…⁷  Code
##   &lt;chr&gt;   &lt;dbl&gt; &lt;fct&gt;      &lt;chr&gt;     &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;chr&gt;     &lt;dbl&gt; &lt;int&gt;
## 1 I1002   0.208 DE         O          1975 Other   Elec    All           1     1
## 2 I1003   0.622 C1         O          2004 Other   Other   All           5     1
## 3 I1004   0.962 C1         O          1987 Other   Elec    All           5     1
## 4 I1005   0.640 C1         O          1930 Other   Other   All           4     1
## 5 I1013   0.241 C2         O          2003 Other   Elec    All           3     1
## 6 I1015   0.463 DE         R          1989 Elec    Other   All           2     1
## # … with 2 more variables: ResTariffallocation &lt;fct&gt;,
## #   ResStimulusallocation &lt;fct&gt;, and abbreviated variable names ¹​SOCIALCLASS,
## #   ²​OWNERSHIP, ³​BUILT.YEAR, ⁴​HEAT.HOME, ⁵​HEAT.WATER, ⁶​WINDOWS.doubleglazed,
## #   ⁷​HOME.APPLIANCE..White.goods.</code></pre>
<p>Here we have, among others, the built year of the building, the type of heating and the number of appliances (see <code>?Irish</code> for more details). We also have some extra information in the following slot:</p>
<pre class="r"><code>extra &lt;- as_tibble( Irish$extra )
head(extra)</code></pre>
<pre><code>## # A tibble: 6 × 7
##    time   toy dow   holy    tod  temp dateTime           
##   &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt;             
## 1     1 0.986 Wed   FALSE     0     4 2009-12-29 23:00:00
## 2     2 0.986 Wed   FALSE     1     4 2009-12-29 23:30:00
## 3     3 0.986 Wed   FALSE     2     4 2009-12-30 00:00:00
## 4     4 0.986 Wed   FALSE     3     4 2009-12-30 00:30:00
## 5     5 0.986 Wed   FALSE     4     4 2009-12-30 01:00:00
## 6     6 0.986 Wed   FALSE     5     4 2009-12-30 01:30:00</code></pre>
<p>In particular, we have some standard variables indicating the time of year, temperature and time of day (see <code>?Irish</code>).</p>
<p>Now, for the purpose of modelling and of producing <code>ggplot2</code>-based visualizations, it makes sense to try to merge the dataframes on individual consumption (<code>indCons</code>), household information (<code>survey</code>) and other variables (<code>extra</code>) in a single dataframe. Joining <code>indCons</code> with <code>extra</code> is quite simple:</p>
<pre class="r"><code>allDat &lt;- longDat %&gt;% cbind(extra) #left_join(extra, by = NULL)
head(allDat)</code></pre>
<pre><code>##      ID   dem counter time       toy dow  holy tod temp            dateTime
## 1 I1002 0.022       1    1 0.9863014 Wed FALSE   0    4 2009-12-29 23:00:00
## 2 I1002 0.133       2    2 0.9863014 Wed FALSE   1    4 2009-12-29 23:30:00
## 3 I1002 0.094       3    3 0.9863014 Wed FALSE   2    4 2009-12-30 00:00:00
## 4 I1002 0.023       4    4 0.9863014 Wed FALSE   3    4 2009-12-30 00:30:00
## 5 I1002 0.133       5    5 0.9863014 Wed FALSE   4    4 2009-12-30 01:00:00
## 6 I1002 0.090       6    6 0.9863014 Wed FALSE   5    4 2009-12-30 01:30:00</code></pre>
<p>in fact <code>cbind</code> will bind the columns of <code>longDat</code> with 100 copies of <code>extra</code> (one copy for each customer). Hence now we can, for instance, look at the consumption of the first 3 customers as a function of the time of day <code>tod</code>, while distiguishing between working days and weekends:</p>
<pre class="r"><code>allDat %&gt;% filter(ID %in% levels(ID)[c(5, 10, 15)]) %&gt;%
           mutate(weekend = dow %in% c(&quot;Sat&quot;, &quot;Sun&quot;)) %&gt;%
           ggplot(aes(x = tod, y = dem, group = ID, color = ID)) +
           geom_smooth() +
           facet_wrap(~ weekend)</code></pre>
<p><img src="/sc1/tidyverse/data_reshaping_tidyr_files/figure-html/unnamed-chunk-24-1.png" width="960" style="display: block; margin: auto;" />
As you can see, customer <code>I1024</code> is probably at home during afternoon weekends, hence his consumption is higher than during working days.</p>
<p>Now, how to add also the information in <code>survey</code> to <code>allDat</code>? The way to do it is:</p>
<pre class="r"><code>allDat %&lt;&gt;% left_join(survey, by = &quot;ID&quot;) %&gt;%
            as_tibble()
head(allDat)</code></pre>
<pre><code>## # A tibble: 6 × 21
##   ID      dem counter  time   toy dow   holy    tod  temp dateTime           
##   &lt;chr&gt; &lt;dbl&gt;   &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;fct&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dttm&gt;             
## 1 I1002 0.022       1     1 0.986 Wed   FALSE     0     4 2009-12-29 23:00:00
## 2 I1002 0.133       2     2 0.986 Wed   FALSE     1     4 2009-12-29 23:30:00
## 3 I1002 0.094       3     3 0.986 Wed   FALSE     2     4 2009-12-30 00:00:00
## 4 I1002 0.023       4     4 0.986 Wed   FALSE     3     4 2009-12-30 00:30:00
## 5 I1002 0.133       5     5 0.986 Wed   FALSE     4     4 2009-12-30 01:00:00
## 6 I1002 0.09        6     6 0.986 Wed   FALSE     5     4 2009-12-30 01:30:00
## # … with 11 more variables: meanDem &lt;dbl&gt;, SOCIALCLASS &lt;fct&gt;, OWNERSHIP &lt;chr&gt;,
## #   BUILT.YEAR &lt;dbl&gt;, HEAT.HOME &lt;chr&gt;, HEAT.WATER &lt;chr&gt;,
## #   WINDOWS.doubleglazed &lt;chr&gt;, HOME.APPLIANCE..White.goods. &lt;dbl&gt;, Code &lt;int&gt;,
## #   ResTariffallocation &lt;fct&gt;, ResStimulusallocation &lt;fct&gt;</code></pre>
<p>where we used <code>left_join</code> to do the merging and <code>as_tibble</code> to convert the <code>data.frame</code> to a <code>tibble</code> (simply because it prints out more nicely). In <code>left_join</code> we set <code>by = "ID"</code>, because <code>ID</code> is the common variable that we use to the matching between the demand data in <code>allDat</code> and the household information data in <code>survey</code>. In this case <code>ID</code> is said to be a primary key of the <code>survey</code> dataframe because it uniquely identifies each of its rows. It is also a foreign key because it allows to associate each row of <code>allDat</code> to one of the rows of <code>survey</code>. Having added the survey information, we can, for example, check how the distribution of the total per-customer yearly consumption changes with the number of appliances:</p>
<pre class="r"><code>allDat %&gt;% group_by(ID) %&gt;%
   summarise(dem = sum(dem),
             appli = first(HOME.APPLIANCE..White.goods.)) %&gt;%
   ggplot(aes(x = dem, group = appli, colour = appli)) +
   geom_density()</code></pre>
<p><img src="/sc1/tidyverse/data_reshaping_tidyr_files/figure-html/unnamed-chunk-26-1.png" width="768" style="display: block; margin: auto;" />
Hence, it seems that the (total, per customer) consumption increases with the number of white goods (this becomes clearer if you consider the whole data set rather than a subset of 100 customers, as done here).</p>
<p>There are different types of “mutating” joins:</p>
<ul>
<li><code>left_join(d1, d2)</code> preserves all the observations in <code>d1</code>, even if there is no corresponding row in <code>d2</code> (the missing values will be filled with NAs). The rows in <code>d2</code> whose key values does not match any row in <code>d1</code> will be discarded. For example:</li>
</ul>
<pre class="r"><code>d1 &lt;- data.frame(key = factor(c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;), levels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)),
                 x1 = 1:4)
d2 &lt;- data.frame(key = factor(c(&quot;A&quot;, &quot;C&quot;), levels = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;)),
                 x2 = c(TRUE, FALSE))

left_join(d1, d2)</code></pre>
<pre><code>##   key x1   x2
## 1   A  1 TRUE
## 2   A  2 TRUE
## 3   B  3   NA
## 4   B  4   NA</code></pre>
<ul>
<li><code>right_join(d1, d2)</code> preserves all the observations in <code>d2</code>:</li>
</ul>
<pre class="r"><code>right_join(d1, d2)</code></pre>
<pre><code>##   key x1    x2
## 1   A  1  TRUE
## 2   A  2  TRUE
## 3   C NA FALSE</code></pre>
<ul>
<li><code>full_join(d1, d2)</code> preserves all the rows in both <code>d1</code> and <code>d2</code>, for example:</li>
</ul>
<pre class="r"><code>full_join(d1, d2)</code></pre>
<pre><code>##   key x1    x2
## 1   A  1  TRUE
## 2   A  2  TRUE
## 3   B  3    NA
## 4   B  4    NA
## 5   C NA FALSE</code></pre>
<ul>
<li><code>inner_join(d1, d2)</code> preserves only the row whose key appears in both data sets, for example:</li>
</ul>
<pre class="r"><code>inner_join(d1, d2)</code></pre>
<pre><code>##   key x1   x2
## 1   A  1 TRUE
## 2   A  2 TRUE</code></pre>
<p>There are also “filtering” joins, such as the <code>semi_join</code>:</p>
<pre class="r"><code>semi_join(x = d2, y = d1)</code></pre>
<pre><code>##   key   x2
## 1   A TRUE</code></pre>
<p>which keeps all the rows of its <code>x</code> argument that have matching key values in <code>y</code>. The main difference with an <code>inner_join</code> is that in the <code>semi_join</code> the rows of <code>x</code> are never duplicated in the presence of multiple matches (for example the first value of <code>key</code> in <code>d2</code> matches the values of <code>key</code> in the first and second row of <code>d1</code>, hence <code>inner_join</code> produces two rows). The complement of the output of <code>semi_join</code> is obtained using the <code>anti_join</code>:</p>
<pre class="r"><code>anti_join(x = d2, y = d1)</code></pre>
<pre><code>##   key    x2
## 1   C FALSE</code></pre>
<p>which returns the rows of <code>x</code> which <strong>do not</strong> have a match in <code>y</code>.</p>
<p>Going back to our electricity demand data, it is interesting to quantify what is the memory cost of building our long <code>data.frame</code> containing all the variables (<code>allDat</code>). The sizes of the original data sets are:</p>
<pre class="r"><code>indCons %&gt;% object.size() %&gt;% format(&quot;MB&quot;)</code></pre>
<pre><code>## [1] &quot;12.9 Mb&quot;</code></pre>
<pre class="r"><code>survey %&gt;% object.size() %&gt;% format(&quot;MB&quot;)</code></pre>
<pre><code>## [1] &quot;0.4 Mb&quot;</code></pre>
<pre class="r"><code>extra %&gt;% object.size() %&gt;% format(&quot;MB&quot;)</code></pre>
<pre><code>## [1] &quot;0.7 Mb&quot;</code></pre>
<p>so the total memory used is less than 15MB. But:</p>
<pre class="r"><code>allDat %&gt;% object.size() %&gt;% format(&quot;MB&quot;)</code></pre>
<pre><code>## [1] &quot;217.9 Mb&quot;</code></pre>
<p>so the long data set must contain quite a lot of redundant information! For instance, the data in <code>extra</code> is repeated 100 times (once per customer) in <code>allDat</code>, and that alone should cost us around 70 MB. This is something to keep in mind when working with larger data sets.</p>
</div>
<div id="further-topics" class="section level2">
<h2>Further topics</h2>
<p>Here we presented the main tools provided by <code>dplyr</code> and <code>tidyr</code> for data transformation and reshaping. Other <code>tidyr</code> functions that you might find useful are:</p>
<ul>
<li><code>separate</code> which allows you to break a variable (e.g. age_sex = “20_male”) into its components (age = 20 and sex = “male”);</li>
<li><code>unite</code> which does the opposite;</li>
<li><code>complete</code> which is particularly useful to find out whether your data set has implicit missing values.</li>
</ul>
<p>Specific “Tidyverse” packages for data cleaning/manipulation that we have not covered, but that you will probably need at some point are:</p>
<ul>
<li><code>stringr</code> for handling strings;</li>
<li><code>lubridate</code> for handling dates and times;</li>
<li><code>forcats</code> for handling factor variables.</li>
</ul>
<p>You might also be interested in looking at the “tidy” functional programming tools provided by the <code>purrr</code>. If, instead, you feel that you are getting excessively excited about the Tidyverse, you could try to curb your enthusiasm by reading <a href="https://github.com/matloff/TidyverseSkeptic">this</a>.</p>
</div>



  <footer>
  

<script src="//yihui.name/js/math-code.js"></script>
<script async src="//mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script>

<script async src="//yihui.name/js/center-img.js"></script>


<script type="text/javascript">
var sc_project=12110974;
var sc_invisible=1;
var sc_security="9b171880";
</script>
<script type="text/javascript"
src="https://www.statcounter.com/counter/counter.js"
async></script>
<noscript><div class="statcounter"><a title="Web Analytics"
href="https://statcounter.com/" target="_blank"><img
class="statcounter"
src="https://c.statcounter.com/12110974/0/9b171880/1/"
alt="Web Analytics"></a></div></noscript>








  


<p align=right>

<a href='https://github.com/awllee/sc1/blob/master/content/tidyverse/data_reshaping_tidyr.Rmd'>View source</a>

|

<a href='https://github.com/awllee/sc1/edit/master/content/tidyverse/data_reshaping_tidyr.Rmd'>Edit source</a>

</p>





<script src="https://utteranc.es/client.js"
        repo="awllee/sc1"
        issue-term="pathname"
        label="utterance"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>



  











<script src="//cdn.jsdelivr.net/combine/gh/highlightjs/cdn-release@9.12.0/build/highlight.min.js,gh/highlightjs/cdn-release@9.12.0/build/languages/r.min.js,gh/highlightjs/cdn-release@9.12.0/build/languages/yaml.min.js,gh/highlightjs/cdn-release@9.12.0/build/languages/tex.min.js,npm/@xiee/utils/js/load-highlight.js" defer></script>



  
  <hr>
  <div class="copyright">© 2020 <a href="https://sites.google.com/view/anthonylee">Anthony Lee</a>, <a href="http://www.bristol.ac.uk/maths/people/feng-yu/index.html">Feng Yu</a>, <a href="https://people.maths.bris.ac.uk/~tk18582/">Tobias Kley</a>, <a href="https://mfasiolo.github.io/">Matteo Fasiolo</a></div>
  
  </footer>
  </article>
  
  </body>
</html>

